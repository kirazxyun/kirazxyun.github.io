(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{51:function(p,v,_){"use strict";_.r(v);var s=_(0),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var p=this,v=p.$createElement,_=p._self._c||v;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"浅谈前后端分离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浅谈前后端分离","aria-hidden":"true"}},[p._v("#")]),p._v(" 浅谈前后端分离")]),_("p",[p._v("对于前后端分离这个命题，我觉得自己是个很幸运的人，因为我只经历过一小段那种在jsp里写js代码的时期，当我正式工作，我就已经开始有了一个较为完整的前端开发环境，也算是开始了前后端开发分离的模式。")]),_("p",[p._v("一直以来，我觉得自己已经理解了什么是前后端分离，但是当有人问我什么是前后端分离的时候，我开始很迷茫，难道只是把代码仓库分开了就叫做分离吗。我想并不是这样的，它应该有着更加深层次的理解。于是我开始找各种博客、社区，去看大家都是怎么看的，今天我觉得自己有那么一些理解，我想我应该将它写下来。\t\n")]),_("h3",{attrs:{id:"一、“原始”的一把手时代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、“原始”的一把手时代","aria-hidden":"true"}},[p._v("#")]),p._v(" 一、“原始”的一把手时代")]),_("p",[p._v("现在我知道，我在jsp里写js代码的时候，我的工作叫做页面仔。那个时候，一个应用，java工程师可以从页面到业务，到底层逻辑全部包圆了，他们将js代码包含在jsp中，这样js就会随着动态生成的html页面发送到浏览器起到他该起的作用。\t为了实现一些公用的组件，也会封装组件，将js代码分散到组件的jsp中，而组件参数则是通过模板语法去填充。")]),_("p",[p._v("而这样的代码带来的问题是特别的明显的，代码上，变量全局污染严重，代码复用性差，可读性更差。再说环境上的，前端强依赖于后端环境，因为代码是嵌在后端代码中的，如果后端没有提前服务，或者服务、环境出现了一点点问题，都可能导致应用无法运行，前端无法开发。再者，前后端都无法专注在自己的代码上，你中有我，我中有你，前端变成了除了java其他什么都会的java工程师，后端成了会堆砌前端代码的前端工程师。")]),_("p",[p._v("从工作流程上来说，这个时期，开发流程是这样的：")]),_("p",[p._v("需求评审")]),_("p",[p._v("产品出原型")]),_("p",[p._v("后端至少配个路由让前端能够运行jsp")]),_("p",[p._v("前端在jsp文件上写html内容，运行后端环境，在浏览器中调试（我也不明白为什么要这样）")]),_("p",[p._v("后端根据前端的jsp文件修改一些内容")]),_("p",[p._v("集成")]),_("p",[p._v("如果有问题")]),_("p",[p._v("前端返工")]),_("p",[p._v("后端返工")]),_("p",[p._v("再次集成")]),_("p",[p._v("交付")]),_("p",[p._v("从这个工作流程中，我们可以发现，前后端在模板这一块一定会是串行的状态，后端没有配服务，前端就无法运行，后端没等到前端的写好jsp，也无法页面测试。最致命的是，原本html、css和js可以在轻量级的编辑其中就能完成的，现在却要在idea或者eclipse这样的种的后端ide中编辑和运行，当你在调试一个问题的时候，要做什么：")]),_("p",[p._v("首先，启动整个应用")]),_("p",[p._v("在浏览器中看错误输出")]),_("p",[p._v("在返回的html中打各种断点猜测原因\t（你甚至没办法临时修改一下代码看看到底错在哪）")]),_("p",[p._v("当这个时候后端环境出现问题")]),_("p",[p._v("好了，你可以休息一下")]),_("p",[p._v("好不容易你定位出了一个问题")]),_("p",[p._v("发现只是名称重复了，呜呼哀哉，为何浪费生命")]),_("p",[p._v("而且你会发现，你一整天中有大部分时间都在呼唤后端小哥哥，这环境是又咋了，你又提交了什么，快过来看看，然后发着呆等待小哥哥大战三百回合后告诉你，我错了，我的变量名称引用错了。")]),_("p",[p._v("其实我是经历过这个时期的，那时的我差点因为这个问题哭了，因为太尼玛艰难了。")]),_("h3",{attrs:{id:"二、幸福的第一阶段前后端分离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、幸福的第一阶段前后端分离","aria-hidden":"true"}},[p._v("#")]),p._v(" 二、幸福的第一阶段前后端分离")]),_("p",[p._v("幸好，在我完成了更加艰难的毕业设计，再次回归的时候，幸福的日子就开始了。前端有了自己的环境和代码管理，再不用追着后端小哥哥搞环境问题了，那种幸福感真的是指数级提升的。")]),_("p",[p._v("我们来看一下这个时期的代码状态，前后端各自有代码仓库，前端资源独立部署到前端服务器，后端代码中依然存在jsp，只是简化为只有页面基本框架，虽然还是带有模板填充，但都是最基本和简单的，例如编辑页面中输入框的值，权限，api变量等等。")]),_("p",[p._v("从环境上，前端有了构建工具，可以实现模块化，打包，部署和提供本地服务。前端开发的时候，不用再以来后端环境，可以通过工具提供本地开发环境，mock数据，进行html和js开发，编辑器也可以使用更加适合的sublime等。前端可以部署到Nginx，提供并发量而且还可以通过cdn让请求速度更加的快速，还有是充分利用了浏览器的缓存。")]),_("p",[p._v("再从开发流程上，现在的状态是：")]),_("p",[p._v("需求评审")]),_("p",[p._v("前后端定义好接口（参数、返回值，请求类型等）")]),_("p",[p._v("前后端各自开发")]),_("p",[p._v("前端部署开发机，并将html发给后端")]),_("p",[p._v("后端套jsp页面，并部署开发机")]),_("p",[p._v("前后端各自测试")]),_("p",[p._v("如有问题")]),_("p",[p._v("前端排查并部署开发机")]),_("p",[p._v("后端排查并部署开发机")]),_("p",[p._v("再次测试")]),_("p",[p._v("交付")]),_("p",[p._v("从这个流程上，我们可以很真实的感觉到，前后端的开发终于可以并行了，虽然还是存在转化jsp这一步，但他的比重和影响已经是很小了。而且对于前端开发来说，最最重要的是，脱离了后端环境的限制，可以玩自己的，并且在调试问题的时候，可以直接利用本地代码进行问题排查和定位，并随时调试代码。大大的提高了前端的开发效率，当然也就提高了整个应用的开发效率。")]),_("p",[p._v("但是呢，我们也不得不面对jsp转化这个问题，它的影响依旧是不容忽视的。每个页面，一旦被转化为jsp，页面元素的修改和调试就变得艰难，因为我们不得不再次启动后端环境去调试。而且转化jsp这个过程，因为是后端小哥哥们负责的，这一群钢铁直男，是不会管你设置了多少精妙的class和html结构的，一不小心就会出现各种各样的奇葩问题。")]),_("p",[p._v("而且路由依旧掌控在后端，当你需要加个页面的时候，依旧显得那么不自由。")]),_("p",[p._v("再从前后端分工来说，依旧存在这你中有我，我中有你的尴尬情况。")]),_("h3",{attrs:{id:"三、理想的spa时代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、理想的spa时代","aria-hidden":"true"}},[p._v("#")]),p._v(" 三、理想的spa时代")]),_("p",[p._v("可以说，第一阶段的前后端分离是不彻底的，它的痛点依旧是十分明显和难以忍受的，但是它确实提高了效率，在那个前端开发人员的水平普遍还不是很高，而且框架不成熟且人力不足的情况下，这已经是我们能做到的最好的框架。")]),_("p",[p._v("而在前端各类框架和技术漫天飞舞的这个时代，我们技术演进已经变得不可避免和必须去做了。彻底的前后端分离，将模板和路由转移到前端，后端人员专注于提供接口，其余的交付前端实现。")]),_("p",[p._v("这个模式下，前端不仅要控制页面交互，还要控制路由、通过ajax返回的数据渲染前端页面。工作流程再次变化为：")]),_("p",[p._v("需求评审")]),_("p",[p._v("前后端定义接口")]),_("p",[p._v("前端开发页面和路由")]),_("p",[p._v("后端并行开发业务和接口")]),_("p",[p._v("联调接口")]),_("p",[p._v("处理问题")]),_("p",[p._v("前端排查并修复")]),_("p",[p._v("后端排查并修复")]),_("p",[p._v("交付")]),_("p",[p._v("我们可以很清楚的看出，这个流程变短了，前后端完全并行，只剩下接口的关系。甚至我们还可以对接口进行优化，通过数据模拟系统，为前端提供模拟数据，对后端进行接口测试，也就是只要接口过关，前后端也可毫无关系的进行开发，到时候前后端各自部署上测试就行了，后端不用再痛苦于模板，前端不再痛苦于修改样式和结构。")]),_("p",[p._v("最后，我想说前后端分离不是为了分离而分离，单纯的代码分离并不算。前后端分离，还有项目独立、环境独立、服务独立、并行开发、专注于所长、提升效率等等。")])])}],!1,null,null,null);v.default=a.exports}}]);