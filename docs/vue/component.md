# 漫谈vue组件开发

组件作为vue描述页面的方式,是vue核心内容之一.经过将近一年的vue项目开发,开发过各种类型的组件,也形成了一套自己组装vue组件的思路,遂以此为题,总结经验.

## 为什么组件化
人的大脑处理信息的能力是有限的,面对一个有复杂度的东西,要想一口气理清并不容易.即使你足够聪明能够一次性处理这些复杂逻辑关系,如何让你的小伙伴理解,并进行后期维护和拓展,也是一项艰难的问题.

但是,人虽然不能一次性处理掉复杂逻辑,但是人擅长于处理关系.什么意思呢,就是如果将一个复杂的需求,拆分成一个个小而独立的需求,然后再让你去指挥它们完成这个复杂需求,就相对容易的多.也就是所谓的化整为零,各个击破.

所以体现在vue上面就是用棵组件树来描述用户界面,这棵树由各种组件堆叠而成.每个组件都是一个个vue实例,拥有自己的属性和方法,可以渲染出界面某一个区块.于是我们的关注点就从一个大而杂的页面,变成关注一个个小而简单的组件.

![组件树](./images/component-tree.png)

## 如何组织组件
组件化是一种抽象，如何使用和落实它影响着组件化的效果。这里，我们将这颗组件树上的组件分为3种类型：
  1. 基础组件
  2. 业务组件
  3. 页面组件

### 基础组件
基础组件也可以说成是通用组件，意思是它不为业务所限，在多个应用中都能找到应用场景。例如小小的一个Button组件、Input组件，或者大一点的Table组件、Menu组件等等。这类组件通过极致的抽象，互相独立，功能完善，脱离业务，作为每一个系统的基础而存在。而且，当你觉得某个组件不足以支撑你的野心，你完全快速的替换掉它并且不影响其他组件运行。

当然，这类组件的越是完善，构建一个系统就越是便捷和简单。而且，我们通过规范组件样式，统一组件架构，将这类组件规划在一起的时候，就变成了一个我们熟悉的词-组件UI库。目前大热的element-ui、iview等都是vue组件UI库的典范。

### 业务组件
当然，每个公司，甚至每个项目都有属于自己的特色的业务。比如CDN业务中很常见的域名选择，动则上十几万的域名数据，且在筛选时需要根据不同条件去进行，按照目前ui库提供的select组件根本无法满足，只能根据这个业务需要，专门做一个组件来方便用户使用。

从这边可以看出来，业务组件相对于基础有一大特点：业务强关联，应用场景受限

### 页面组件
页面组件，可以将其形容为组件的容器，是所有基础组件、业务组件的上级组件。一般，一个页面组件对应一个路由，所以也可以称之为路由视图组件。

那这3类组件最终组成了组件树上的各个节点，页面组件包含业务组件和基础组件，业务组件又包含有基础组件。

## 组件开发
了解大概念的组件化，我们将目光往单个组件上转移。要让一颗组件树上的组件更好的协作，组件的设计与编写至关重要，这边我们有几个原则：

1. 易于修改和维护
2. 可复用
3. 可读性高
4. 接纳团队合作性开发

前面几点很好理解，讲一下什么是接纳团队合作性开发：我们不是单打独斗的，我们是一个团队，我们每一个人写的每一个组件，都会有可能由另一个人来接手，所以我们需要一套开发规范来约束开发，这样无论谁写的代码，大家都能较快理解和进行维护。

### devtool
工欲善其事，必先利其器。因为.vue文件最终都被编译成js了，所以要调试真的很麻烦。我一开始的方法是在要看状态的地方，打一个console，然后再按着这个console来找到文件，然后设置断点调试，但是又看不到真个组件的全貌。

后来才发现devtool这个chrome插件，真的是神器，不仅可以直观的看到组件树，查看每个组件当前的状态，还能看vuex和事件调用。这样调试起来就顺手的多。


### 构成
首先，我们将组件划分为几个模块，来看组件的构成
1. 外观
2. 数据状态
3. 事件通讯
4. 内部逻辑

#### 外观
前面说过，组件负责着页面某一块内容逻辑交互和渲染，所以一般组件都会有自己的渲染内容，这块就是外观，主要由template/css/slot组成，其中slot是交给外部来填充的内容。

这边需要注意的一个点是 __样式必须限制作用域__：

因为.vue文件允许我们将template写在同一个文件里面，方便而且直观，这就可能会引导大家都将样式写在组件里。但是呢，有些样式可能是本组件才需要的，我们不希望它影响到其他组件，特别是直接对标签的样式定义。然而因为组件的样式最终会被编译到同一个style文件里，变成全局的样式，所以就会影响到其他组件的样式。

所以，我们倡导写组件样式有两种：
1. 单文件组件内的样式加scoped
2. 每个组件一个单独的样式表，并以组件名作为前缀

第一点，样式加上scoped，最终dom上的节点还有相应的样式，都会被加上data-v-hash来区分作用范围。
第二点，是我比较推荐和倾向的，特别是对基础组件，一个单独的样式表和前缀，让样式编写更加优雅。

#### 数据
模板的展示结果是根据状态来的，而这些状态就是组件里面的数据。组件的数据来自3个选项：props、data、computed。

其中：props来自于外部、data为自定义变量、computed为计算结果

##### （1）承接props的3种方式
我们拿到数据后可能用途有3种，分别对应不同的处理方式
1. 只拿来用-直接使用
2. 作为局部变量使用（一般是需要修改数据）- data上定义变量，并将props赋值给它
3. 需要处理后使用 - 用computed计算后返回

> 当数据需要变成局部变量来使用，并且props格式是个引用类型的话，一定要进行深度克隆，原因大家都懂的。

##### （2）往外传递数据的方式
组件往外传递数据的方式只有一种，那就是事件。

所以组件的组件的通讯还可以总结为 __props down, event up__

#### 事件
组件内的事件，一般用于通讯。

说到组件，就不得不提v-model，当我们在设计一个表单类组件的时候，比如时间选择框，一定要实现v-model，方便数据的双向绑定。

#### 逻辑
当我们定义好外观和对外的数据交互，剩下就是内部逻辑实现了，这部分由主要由使用methods、声明周期、watch来控制数据变化和逻辑。

首先methods就不用讲了，就是方法，将复杂的处理过程划分成一个个处理方法用来到处调用，这边要注意的就是保持每个方法单一，不要写太多东西导致代码不清晰。

然后是生命周期，我们需要在组件的声明周期的各个节点中做一些事情来，比如组件开始渲染的时候，我们要先从后端拿数据，这就需要在created的时候进行。

然后是watch了，说到watch就得说一下computed：

##### （1）computed使用姿势
其实我更喜欢称computed为衍生数据，它有两大使用场景
1、衍生数据：通过props、data，组合运算生成新的数据
2、代理数据：定于get用来衍生取数据，set用来修改数据时，映射并更新到它的衍生

##### （2）computed or watch
其实watch做得事情跟computed很像，都是根据数据变化触发的，但是呢，两者有很大的不一样：

1. computed是多对一，也就是适用于监听多个数据变化来生成一个数据，而watch是一对多，监听一个数据状态的变化，进而处理其他数据。
2. computed只用来生成数据，不建议做其他处理，而watch可以，无论是修改数据还是处理其他事情。

以上，就是一个组件的构成，但是其实一个组件不一定会拥有以上4个部分，但是脱离不了这个范围。

### 组件的开发

#### 1、理清楚需求
#### 2、设计好API
#### 3、组件初始化
#### 4、处理好逻辑



