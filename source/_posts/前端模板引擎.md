# 什么是模板引擎
模板引擎是做什么  
简单来说，一个字符串中有变量，比如下面这样：

```
var tpl = "my name is <%name%>, I'm <%age%> years old.";
```
模板引擎就是通过解析字符串，根据输入的数据，输出html，例如：
```
var data = {
    name: 'lily',
    age: 18
};
var tpl = "my name is <%name%>, I'm <%age%> years old.";

tplEngine(tpl, data);
//"my name is lily, I'm 18 years old."
```
上面是一个超级简单的例子，但是现实是，我们遇见的需要解析的模板都是复杂的，例如if、for、while等等，看一下下面的模板：

```
var tpl = '<% for(var i = 0; i < posts.length; i++) {' +
			'var post = posts[i]; %>' +
			'<% if(!post.expert) { %>' +
				'<span>post is null</span>' +
			'<% } else { %>' +
				'<a href="#">' +
					'<% post.expect %> at <% post.time %>' +
				'</a>' +
			'<% } %>' +
		  '<% } %>';
```
是不是觉得眼快花了，其实将上面的字符和变量标识去掉就变成了下面这样：

```
for(var i = 0, len = posts.length; i < len; i++) {
    var post = posts[i];
    if(post.expert) {
        <span>post is null</span>
    } else {
        <a href="#"> post.expert at post.time</a>
    }
}
```
所以上面的模板要实现的是效果是，如下：

```
var posts = [{
    expert: 1,
    time: 1
}, {
    expert: 2,
    time: 2
}, {
    expert: false
}];

/**********************

<a href="#">1 at 1</a>
<a href="#">2 at 2</a>
<span>post is null</span>

***********************/

```
而一个最简单的模板引擎也一定要能应付上面给出的情况。  
为了能实现一个这样功能的模板引擎，我们接下来开始了解模板引擎实现的原理。

# 模板引擎实现原理
### 一、提取要匹配的内容
要从一段字符串中提取东西，相信大家都知道要用正则，
没错我们正是要通过正则来实现匹配内容的提取。  

回过头来看一下最简单的例子：  

```
var tpl = "my name is <%name%>, I'm <%age%> years old.";
```
我们假设有一个模板引擎名为tplEngine，这个模板引擎接受两个参数，一个是模板，一个是数据,例如下面这样：

```
var data = {
    name: 'lily',
    age: 18
};
tplEngine(tpl, data);
//"my name is lily, I'm 18 years old."
```
现在想一下如何实现上面的转换，其实最简单的方法就是利用replace来实现，像这样：

```
var tplEngine = function(tpl, data) {
    var reg = /<%([^%>]+)?%>/g;
    return tpl.replace(reg, function($0, $1) {
        return data[$1];
    });
};
```
验证一下：

结果很棒，是我们想要的结果。  
但是事情远远还没有结束：如果，我们的数据结构是这样的：

```
var data = {
    name: 'lily',
    info: {
        age: 18
    }
};
var tpl = "my name is <%name%>, I'm <%info.age%> years old.";
```
这就很尴尬了是吧，因为data["info.age"]肯定是要undefined的。这个时候，大家肯定会想如果能直接执行js就好了，就像eval一样，所以，如果能解析成这样：

```
"my name is" + data.name + ", I'm" + data.info.age + "years old.";
```
那就没什么问题了。  
但是，如果有for循环呢，看这个：

```
var tpl = 'Posts: ' + 
          '<% for(var i = 0; i < post.length; i++) {'+
            '<a href="#"><% post[i].expert %></a>' + 
          '<% } %>'
```
如果按我们的想法走，将匹配出的内容解析成可执行的js，也就是这样：

```
'Posts: ' + 
    for(var i = 0; i < post.length; i++) { +
        '<a href="#">' + post.expert + '</a>' +
    }
```
这，肯定要报错的。  
如果，能把for后面的加号去掉，好像会是一个不错的结构：

```
'Posts: ' + 
    for(var i = 0; i < post.length; i++) { 
        '<a href="#">' + post.expert + '</a>' 
    }
```
看起来更像是一个能执行的代码，现在我们找个结构把它存起来。
### 2、装载数组
记得我们组装字符串最常用的工具吗，就是数组了，用它来将字符串存起来：

```
var r = [];
r.push('Posts: ');
r.push(for(var i = 0; i < post.length; i++) {);
r.push('<a href="#">' + post.expert + '</a>');
r.push(});
```
这样，就把结构存起来了，但是上面的第二句和第四局，不太对啊，这样要报错啦，
好吧，赶紧把for拿出来

```
var r = [];
r.push('Posts: ');
for(var i = 0; i < post.length; i++) {);
    r.push('<a href="#">' + post.expert + '</a>');
}
```
怎么样，是不是特别的完美，跟我们平常写的字符串拼接很像。  
但是怎么把一个字符串转换成这个样子呢。
### 3、分辨js逻辑部分

这边就要介绍一个黑科技了，就是js内置的构造函数Fucntion：

```
new Function (ag1, ag2, ag3,..., 函数体)；
//所有参数皆为字符串
```
是不是觉得眼前一亮啊，有了这个方法，我们就能将字符串解析出来的js部门和真正的字符串部分连接成一个字符串，以此来创建一个可执行的函数。  
 
```
var fn = new Function("data", "var r = []; for(var i in data){ r.push(data[i]); } return r.join(' ')");

var data = {
    name: lily,
    age: 18
}
fn(data);
//lily 18
```
我们这边不再用replace，因为逻辑变得复杂，用replce有点吃力，我们还是多搬几块砖把。  
但是现在不能用match，为什么呢，因为match只能匹配到第一个，我们这边得用exec来循环匹配出所有的js逻辑。  
这样：

```
var match = null;
var reg = /<%([^%>]+)?%>/g;
var tpl = "my name is <%name%>, I'm <%age%> years old.";
while(match = reg.exec(tpl)) {
    console.log(match);
}
```

现在还有一个问题是，如果分辨js和真正的字符串呢？  
其实用正则匹配出js，其余的就是真正的字符串了，而exec中匹配出的信息就带有index信息，正好用来截取。  
这样我们的引擎函数就有雏形了

### 4、引擎函数


```
var tplEngine = function (tpl, data) {
	var match = null;
	var reg = /<%([^%>]+)?%>/g;
	var code = 'var r = [];\n';
	var cursor = 0; //定位代码的最后一截
	var add = function(line, js) {
	    code += (js ? ('r.push(' + line + ');\n') : ('r.push("' + line + '");\n'));
	};

	while(match = reg.exec(tpl)) {
		var index = match.index;
		add(tpl.slice(cursor, index)); //截取非js部门
		add(match[1], true);
		cursor = index + match[0].length;
	}

	add(tpl.substr(cursor, tpl.length - cursor));

	code += 'return r.join("");';
	var fn = new Function(code);

	return fn.apply(data);
};
```
我们用上面这个函数来解析最开始的例子：

```
var data = {
    name: 'lily',
    info: {
        age: 18
    }
};
var tpl = "my name is <%this.name%>, I'm <%this.info.age%> years old.";
tplEngine(tpl, data);
//"my name is lily, I'm 18 years old."
```
效果不错啊，那么加上for循环呢

```
var posts = [{
    expert: 1,
    time: 1
}, {
    expert: 2,
    time: 2
}];
var tpl = 'Posts: ' + 
          '<% for(var i = 0; i < this.posts.length; i++) { %>'+
            '<a href="#"><% this.post[i].expert %></a>' + 
          '<% } %>';
tplEngine(tpl, {
    posts: posts
});
```
啊，报错了，看看报错的地方

```
(function() {
var r = [];
console.log(this);
r.push("Posts: ");
r.push( for(var i = 0; i < this.posts.length; i++) { ); //这里报错了
r.push("<a href="#">");
r.push( this.post[i].expert );
r.push("</a>");
r.push( } );
r.push("");
return r.join("");
})
```
这当然是要报错的，大家是否还记得，上面的内容，for循环这些语句是要提取出来的，所以我们还要继续改进：  
做一个for，if，while等的语句判断，当遇见这些内容的时候不要放到r.push里面：  
首先判断的正则：

```
var regForOur = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g;
```
这边只做了简单判断。  
add的判断逻辑也要跟着改一下：

```
var add = function(line, js) {
        if(js) {
            if(regForOut.text(line)) {
                code += line + '\n';
            } else {
                code += 'r.push(' + line + ');\n';
            }
        } else {
            code += 'r.push("' + line + '");\n';
        }
	};
```
所以我们的引擎函数的最终形态是：

```
var tplEngine = function (tpl, data) {
	var match = null;
	var reg = /<%([^%>]+)?%>/g;
	var regForOut = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g;
	var code = 'var r = [];\n';
	var cursor = 0; //定位代码的最后一截
	var add = function(line, js) {
        if(js) {
            if(regForOut.test(line)) {
                code += line + '\n';
            } else {
                code += 'r.push(' + line + ');\n';
            }
        } else {
            code += 'r.push("' + line + '");\n';
        }
	};

	while(match = reg.exec(tpl)) {
		var index = match.index;
		add(tpl.slice(cursor, index)); //截取非js部门
		add(match[1], true);
		cursor = index + match[0].length;
	}

	add(tpl.substr(cursor, tpl.length - cursor));

	code += 'return r.join("");';
	var fn = new Function(code);

	return fn.apply(data);
};
```
我们再试试上面的for循环的那一条：

```
(function() {
var r = [];
r.push("Posts: ");
 for(var i = 0; i < this.posts.length; i++) { 
r.push("<a href="#">"); //哎呀，又报错了
r.push( this.post[i].expert );
r.push("</a>");
 } 
r.push("");
return r.join("");
})
```
这次报错的问题是双引号问题引起的，所以我们在add的时候得把双引号转义一下：

```
var add = function(line, js) {
        if(js) {
            if(regForOut.test(line)) {
                code += line + '\n';
            } else {
                code += 'r.push(' + line + ');\n';
            }
        } else {
            code += 'r.push("' + line.replace(/"/g, '\\"') + '");\n';
        }
	};
```
好了，再试试看


```
//"Posts: <a href="#">1</a><a href="#">2</a>"
```

普天同庆，我们终于做到了。  
所以，最后的最后，引擎函数的如下：

```
var tplEngine = function (tpl, data) {
	var match = null;
	var reg = /<%([^%>]+)?%>/g;
	var regForOut = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g;
	var code = 'var r = [];\n';
	var cursor = 0; //定位代码的最后一截
	var add = function(line, js) {
        if(js) {
            if(regForOut.test(line)) {
                code += line + '\n';
            } else {
                code += 'r.push(' + line + ');\n';
            }
        } else {
             code += 'r.push("' + line.replace(/"/g, '\\"') + '");\n';
        }
	};

	while(match = reg.exec(tpl)) {
		var index = match.index;
		add(tpl.slice(cursor, index)); //截取非js部门
		add(match[1], true);
		cursor = index + match[0].length;
	}

	add(tpl.substr(cursor, tpl.length - cursor));

	code += 'return r.join("");';
	var fn = new Function(code);

	return fn.apply(data);
};
```
这段不到30行的代码就能实现一个简单的模板引擎，其中还有很多是需要补充和晚上的，但我们今天只是为了学习引擎函数的实现原理，就不再细化。  
总结一下：  
> ## 模板引擎的实现原理
> 
> 1.   利用正则匹配出js逻辑。
> 2.   利用数组装载函数体。
> 3.   利用Function形成模板构造函数
> 4.   data放进去
>

目前前端模板引擎非常的多，但是其实现原理都是大同小异的。在原理的基础上，加上各种缓存，预编译等技术，可以大大的提高解析速度。  








